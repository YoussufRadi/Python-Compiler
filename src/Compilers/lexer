package Compilers;

import java_cup.runtime.Symbol;
import java.util.Stack;

%%
%class Lexer
%implements java_cup.runtime.Scanner
%function next_token
%type Symbol
%char
%line
%states SPACE

%{
	//initialize  variables to be used by class
	static Stack<Integer> indentCount = new Stack<Integer>();
	static int count = 0;
	static String lex = "";
	static boolean isIndent = false;
	int index = 0;
	int newIndex = 0;
	static Stack<Symbol> dedents = new Stack<Symbol>();
%}


%init{
    indentCount.push(0);
//Add code to be executed on initialization of the lexer

%init}

%eofval{  
      if (!indentCount.isEmpty() && indentCount.peek() != 0) {
          int pop = indentCount.pop();
          yybegin(YYINITIAL);
          return new Symbol(Symbol.DED, pop + "");
      } 
      return null;
%eofval}

FINALLY=finally
NONE=none
LAMBDA=lambda
GLOBAL=global
IS=is
RETURN=return
YIELD=yield
PASS=pass
PRINT=print
FROM=from
IF=if
ELSE=else
ELIF=elif
TRY=try
EXCEPT=excpet
CONTINUE=continue
BREAK=break
OR=or
NOT=not
AND=and
TRUE=[T|t]rue
FALSE=[F|f]alse
IN=in
RANGE=range
DEF=def
WHILE = while
FOR = for
KEYWORD=str|int
IMPORT=import
CLASS=class
ALPHA=[A-Za-z]
DIGIT=[0-9]
ALPHA_NUMERIC={ALPHA}|{DIGIT}
NUMBER={DIGIT}+("."{DIGIT}+)(E[+-]?{DIGIT}+)?
INTEGER = {DIGIT}+
INDENT=(\t)
NEWLINE = [\n]
WHITE_SPACE=([\ \r\f\b])+
NOSLASHQUOTE = [^\"]
NOSLASHSINGLE = [^\']
SINGLECOMMENT = #[^\n]* \n
MULTIPLECOMMENT = \"\"\"(.|{WHITE_SPACE})*\"\"\"
COMMENTS = {SINGLECOMMENT}|{MULTIPLECOMMENT}
STRINGDOUBLE = \"{NOSLASHQUOTE}*\"
STRINGSINGLE = \'{NOSLASHSINGLE}*\'
STRING = {STRINGDOUBLE}|{STRINGSINGLE}
ID = {ALPHA}({ALPHA}|{DIGIT})*
PACKAGE = (_+{ID}_+)
FUNCTION = {ID}_{ID}


%%
<YYINITIAL> ^[\ \t\r\f\b]*\n {
int tmp = index++;
index = yylength() + newIndex;
newIndex = index - tmp;
index = yylength() + newIndex + 1;
}
<YYINITIAL> ^[\ \t]*\n {
index = yylength();
}
<YYINITIAL> {DEF} {
 return new Symbol(Symbol.DEF, yytext()); } 
<YYINITIAL> {NEWLINE} {
System.out.println("NEWLINE");
isIndent = false;
newIndex = yylength();
return new Symbol(Symbol.NL, ""); 
}

<YYINITIAL> ^[\ \t]* {
count = yytext().length();
 if (count > indentCount.peek()) {
     indentCount.push(count);
     int tmp  = count;
     count = 0;
    System.out.println("Indent");
     return new Symbol(Symbol.IND, tmp+"");
  }
  else if (count < indentCount.peek()) { 
      if (indentCount.contains(count)) {
              int pop = indentCount.pop();
              if ((yylength() + index) < yy_buffer_index)
              yy_buffer_index -= yylength() + index;
              yybegin(YYINITIAL);
              System.out.println("DEDENT");
             return new Symbol(Symbol.DED,pop + "");
      }
      else {
              System.out.println("EROROROROR");
          return new Symbol(Symbol.ERROR, "Unexpected indentation");
      }
  }


}
<YYINITIAL> {INDENT} {
  System.out.println("FIXED INDENT");
  return new Symbol(sym.IND, 33); 
}
<YYINITIAL> {NEWLINE} { 
  return new Symbol(sym.NL, yytext()); 
}
<YYINITIAL> {WHITE_SPACE} { }
<YYINITIAL> {COMMENTS} { }
<YYINITIAL> {KEYWORD} {
  
  return new Symbol(sym.KW, yytext()); 
}
<YYINITIAL> {WHILE} { 
  return new Symbol(sym.WH, yytext()); 
}
<YYINITIAL> {FOR} { 
  return new Symbol(sym.FOR, yytext()); 
}
<YYINITIAL> {IMPORT} {
  
  return new Symbol(sym.IM, yytext()); 
}
<YYINITIAL> {PACKAGE} {
  
  return new Symbol(sym.PK, yytext()); 
}
<YYINITIAL> {FUNCTION} {
  
  return new Symbol(sym.FC, yytext()); 
}
<YYINITIAL> {PRINT} {
  
  return new Symbol(sym.PR, yytext()); 
}
<YYINITIAL> {FROM} {
  
  return new Symbol(sym.FR, yytext()); 
}
<YYINITIAL> {IF} {
  
  return new Symbol(sym.IF, yytext()); 
}
<YYINITIAL> {ELSE} {
  
  return new Symbol(sym.EI, yytext()); 
}
<YYINITIAL> {TRY} {
  
  return new Symbol(sym.TY, yytext());
}
<YYINITIAL> {EXCEPT} {
  
  return new Symbol(sym.EX, yytext()); 
}
<YYINITIAL> {CONTINUE} {
  
  return new Symbol(sym.CN, yytext()); 
}
<YYINITIAL> {OR} {
  
  return new Symbol(sym.OR, yytext()); 
}
<YYINITIAL> {NOT} {
  
  return new Symbol(sym.NT, yytext()); 
}
<YYINITIAL> {AND} {
  
  return new Symbol(sym.AD, yytext()); 
}
<YYINITIAL> {TRUE} {
  
  return new Symbol(sym.TR, yytext()); 
}
<YYINITIAL> {FALSE} {
  
  return new Symbol(sym.FL, yytext()); 
}
<YYINITIAL> {IN} {
  
  return new Symbol(sym.IN, yytext()); 
}
<YYINITIAL> {RANGE} {
  
  return new Symbol(sym.RG, yytext()); 
}
<YYINITIAL> {DEF} {
  
  return new Symbol(sym.DF, yytext()); 
}
<YYINITIAL> {CLASS} {
  
  return new Symbol(sym.CL, yytext()); 
}
<YYINITIAL> {ID} {
  
  return new Symbol(sym.ID, yytext()); 
}
<YYINITIAL> {NUMBER} {
  
  return new Symbol(sym.DL, yytext()); 
}
<YYINITIAL> {INTEGER} {
  
  return new Symbol(sym.INT, yytext()); 
}
<YYINITIAL> {STRING} { 
  
  return new Symbol(sym.ST, yytext()); 
}
<YYINITIAL> {FINALLY} {
  
  return new Symbol(sym.FI, yytext()); 
}
<YYINITIAL> {NONE} { 
  
  return new Symbol(sym.NN, yytext()); 
}
<YYINITIAL> {LAMBDA} {
  
  return new Symbol(sym.LM, yytext()); 
}
<YYINITIAL> {GLOBAL} { 
  
  return new Symbol(sym.GL, yytext()); 
}
<YYINITIAL> {IS} { 
  
  return new Symbol(sym.IS, yytext());  
}
<YYINITIAL> {RETURN} {
  
  return new Symbol(sym.RT, yytext()); 
}
<YYINITIAL> {YIELD} { 
  
  return new Symbol(sym.YD, yytext()); 
}
<YYINITIAL> {PASS} { 
  
  return new Symbol(sym.PS, yytext()); 
}
<YYINITIAL> {ELIF} { 
  
  return new Symbol(sym.ELF, yytext()); 
}
<YYINITIAL> {BREAK} { 
  
  return new Symbol(sym.BR, yytext());  
}
<YYINITIAL> "." { 
  
  return new Symbol(sym.DO, yytext()); 
}
<YYINITIAL> "+" { 
  
  return new Symbol(sym.PO, yytext()); 
}
<YYINITIAL> "-" { 
  
  return new Symbol(sym.MO, yytext()); 
}
<YYINITIAL> "*" { 
  
  return new Symbol(sym.MB, yytext()); 
}
<YYINITIAL> "/" { 
  
  return new Symbol(sym.DB, yytext()); 
}
<YYINITIAL> "=" { 
  
  return new Symbol(sym.AO, yytext()); 
}
<YYINITIAL> "<" { 
  
  return new Symbol(sym.LT, yytext()); 
}
<YYINITIAL> ">" { 
  
  return new Symbol(sym.GT, yytext()); 
}
<YYINITIAL> "==" { 
  
  return new Symbol(sym.EQ, yytext()); 
}
<YYINITIAL> "{" { 
  
  return new Symbol(sym.LC, yytext()); 
}
<YYINITIAL> "}" { 
  
  return new Symbol(sym.RC, yytext()); 
}
<YYINITIAL> "(" { 
  
  return new Symbol(sym.LB, yytext()); 
}
<YYINITIAL> ")" { 
  
  return new Symbol(sym.RB, yytext()); 
}
<YYINITIAL> ";" { 
  
  return new Symbol(sym.SM, yytext()); 
}
<YYINITIAL> "," { 
  
  return new Symbol(sym.FA, yytext()); 
}

<YYINITIAL> "[]" { 
  
  return new Symbol(sym.AA, yytext()); 
}
<YYINITIAL> "[" { 
  
  return new Symbol(sym.LS, yytext()); 
}
<YYINITIAL> "]" { 
  
  return new Symbol(sym.RS, yytext()); 
}
<YYINITIAL> ":" { 
  
  return new Symbol(sym.SC, yytext()); 
}
<YYINITIAL> . { 
  
  return new Symbol(sym.UD, yytext()); 
}
